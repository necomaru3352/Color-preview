/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoColorPreview
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var COLOR_REGEX = /#(?:[0-9a-fA-F]{3,4}){1,2}\b|(?:\b(?:rgb|hsl)a?\([\s\d%.,/]+\))/g;
var ColorWidget = class extends import_view.WidgetType {
  constructor(color) {
    super();
    this.color = color;
  }
  toDOM() {
    const span = document.createElement("span");
    Object.assign(span.style, {
      backgroundColor: this.color,
      display: "inline-block",
      width: "0.9em",
      height: "0.9em",
      marginLeft: "4px",
      borderRadius: "2px",
      border: "1px solid rgba(128, 128, 128, 0.4)",
      verticalAlign: "middle"
    });
    return span;
  }
};
var AutoColorPreview = class extends import_obsidian.Plugin {
  async onload() {
    this.registerEditorExtension(this.colorPlugin());
    this.registerMarkdownPostProcessor((element) => {
      var _a, _b;
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
      const nodesToReplace = [];
      let node;
      while (node = walker.nextNode()) {
        const textNode = node;
        const content = textNode.textContent;
        if (!content)
          continue;
        const matches = Array.from(content.matchAll(COLOR_REGEX));
        if (matches.length > 0) {
          nodesToReplace.push({ textNode, matches });
        }
      }
      for (const { textNode, matches } of nodesToReplace) {
        const content = textNode.textContent;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        for (const match of matches) {
          const color = match[0];
          const index = (_a = match.index) != null ? _a : 0;
          fragment.appendChild(document.createTextNode(content.slice(lastIndex, index + color.length)));
          fragment.appendChild(new ColorWidget(color).toDOM());
          lastIndex = index + color.length;
        }
        fragment.appendChild(document.createTextNode(content.slice(lastIndex)));
        (_b = textNode.parentNode) == null ? void 0 : _b.replaceChild(fragment, textNode);
      }
    });
  }
  colorPlugin() {
    return import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        __publicField(this, "decorations");
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        for (let { from, to } of view.visibleRanges) {
          const text = view.state.doc.sliceString(from, to);
          let match;
          while ((match = COLOR_REGEX.exec(text)) !== null) {
            const pos = from + match.index + match[0].length;
            builder.add(pos, pos, import_view.Decoration.widget({
              widget: new ColorWidget(match[0]),
              side: 1
            }));
          }
        }
        return builder.finish();
      }
    }, { decorations: (v) => v.decorations });
  }
};
